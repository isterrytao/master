#include "xgate.h"
#include "Cpu.h"
#include "PwmCapture_Lcfg.h"

/*
<%- JSON.stringify(mdata, null, '  ') %>
*/

<%
if (mdata.hasOwnProperty('funcIncude')) {
    for(var ch of mdata['funcIncude']) {
%>
#include "<%- ch %>"
<%
    }

}%>


// 在电路上，PWM的输入板级端子与MCU管脚都有反向电路。
// 上述定义中PwmCapture_Cfg.h中定义的都是板级的信号。
// PwmCapture.c PwmCapture.h中的定义的都是MCU管脚信号的方向，




<%
for(var ch of ['SIGIN1', 'SIGIN2']) {
    var edge = 'PWM_TRIGGER_HCS12_NONE';
    if (mdata.hasOwnProperty(ch) && mdata[ch].enable) {
        if (mdata[ch].risingFunc) {
            edge = edge + ' | PWM_TRIGGER_HCS12_RAISING';
        }

        if (mdata[ch].fallingFunc) {
            edge = edge + ' | PWM_TRIGGER_HCS12_FALLING';
        }
    }
%>
#define PWM_CAPTURE_<%- ch %>_TRIGGER_EDGE ( <%- edge %> )
<%
}
%>



#pragma push
#pragma DATA_SEG __GPAGE_SEG XGATE_DATA
#pragma CONST_SEG __GPAGE_SEG XGATE_CONST

const uint8 PwmCapture_ChannelNum = PWM_CAPTURE_CHANNEL_NUM;

PwmCapture_DataType PwmCapture_DataList[PWM_CAPTURE_CHANNEL_NUM] = {
#ifdef PWM_CAPTURE_CP_CHANNEL
    {(uint16 * near) &ECT_TC1, (uint8)((uint8)1U << 1), 1U, PWM_TRIGGER_HCS12_NONE, 0U, 0UL, 0UL, 0UL, 0U}, /**< CP PWM channel */
#endif
#ifdef PWM_CAPTURE_SIGIN1_CHANNEL
    {(uint16 * near) &ECT_TC2, (uint8)((uint8)1U << 2), 1U, PWM_CAPTURE_SIGIN1_TRIGGER_EDGE, 0U, 0UL, 0UL, 0UL, 0U}, /**< SIGIN1 */
#endif
#ifdef PWM_CAPTURE_SIGIN2_CHANNEL
    {(uint16 * near) &ECT_TC3, (uint8)((uint8)1U << 3), 1U, PWM_CAPTURE_SIGIN2_TRIGGER_EDGE, 0U, 0UL, 0UL, 0UL, 0U}, /**< SIGIN2 */
#endif
};

#pragma pop

XGATE_ISR_PROTYPE(PwmXgate_EdgeIsr);

#ifdef PWM_CAPTURE_SIGIN1_CHANNEL
static void onSIGIN1Edge(void) {
<% if (mdata.hasOwnProperty('SIGIN1') && mdata['SIGIN1'].enable && (mdata['SIGIN1'].risingFunc || mdata['SIGIN1'].fallingFunc)) {
    if (mdata['SIGIN1'].risingFunc == mdata['SIGIN1'].fallingFunc) { %>
    <%- mdata['SIGIN1'].risingFunc %>(&PwmCapture_DataList[PWM_CAPTURE_SIGIN1_CHANNEL]);
<%  } else { %>
    if (PwmCapture_IsTriggerRising(&PwmCapture_DataList[PWM_CAPTURE_SIGIN1_CHANNEL])) {
        <% if (mdata['SIGIN1'].risingFunc) { %>
        <%- mdata['SIGIN1'].risingFunc %>(&PwmCapture_DataList[PWM_CAPTURE_SIGIN1_CHANNEL]);
        <% } %>

    } else {
        <% if (mdata['SIGIN1'].fallingFunc) { %>
        <%- mdata['SIGIN1'].fallingFunc %>(&PwmCapture_DataList[PWM_CAPTURE_SIGIN1_CHANNEL]);
        <% } %>
    }
<% }
}%>
    HCS12_ClearGIF(IRQ_LOGIC_NUM_TO_PYH(IRQ_STANDARD_TIM_2));
}
#endif

#ifdef PWM_CAPTURE_SIGIN2_CHANNEL
static void onSIGIN2Edge(void) {
<% if (mdata.hasOwnProperty('SIGIN2') && mdata['SIGIN2'].enable && (mdata['SIGIN2'].risingFunc || mdata['SIGIN2'].fallingFunc)) {
    if (mdata['SIGIN2'].risingFunc == mdata['SIGIN2'].fallingFunc) { %>
    <%- mdata['SIGIN2'].risingFunc %>(&PwmCapture_DataList[PWM_CAPTURE_SIGIN2_CHANNEL]);
<%  } else { %>
    if (PwmCapture_IsTriggerRising(&PwmCapture_DataList[PWM_CAPTURE_SIGIN2_CHANNEL])) {
        <% if (mdata['SIGIN2'].risingFunc) { %>
        <%- mdata['SIGIN2'].risingFunc %>(&PwmCapture_DataList[PWM_CAPTURE_SIGIN2_CHANNEL]);
        <% } %>

    } else {
        <% if (mdata['SIGIN2'].fallingFunc) { %>
        <%- mdata['SIGIN2'].fallingFunc %>(&PwmCapture_DataList[PWM_CAPTURE_SIGIN2_CHANNEL]);
        <% } %>
    }
<% }
}%>
    HCS12_ClearGIF(IRQ_LOGIC_NUM_TO_PYH(IRQ_STANDARD_TIM_3));
}
#endif

void PwmCapture_Start(void) {
    uint16 func;
    uint16 dat;

#ifdef PWM_CAPTURE_CP_CHANNEL
    (void)XGate_AddrGlobalToXGate(&func, HCS12_GetXGateIsrFunc(PwmXgate_EdgeIsr));
    (void)XGate_AddrGlobalToXGate(&dat, &PwmCapture_DataList[PWM_CAPTURE_CP_CHANNEL]);
    XGateIrq_InstallVector(IRQ_STANDARD_TIM_1, func, dat);
    XGate_RouteInterrupt(IRQ_STANDARD_TIM_1, TRUE, 2U);
    ECT_TIOS_IOS1 = 0U; // input capture
    ECT_TCTL4_EDG1A = 1U; // capture on both edge
    ECT_TCTL4_EDG1B = 1U;
    ECT_TIE_C1I = 1U; // enable interrupt;
#endif

#ifdef PWM_CAPTURE_SIGIN1_CHANNEL
    (void)XGate_AddrGlobalToXGate(&dat, &PwmCapture_DataList[PWM_CAPTURE_SIGIN1_CHANNEL]);
    XGateIrq_InstallVector(IRQ_STANDARD_TIM_2, func, dat);
    HC12XIrq_InstallVector(IRQ_STANDARD_TIM_2, onSIGIN1Edge, 0U);
    XGate_RouteInterrupt(IRQ_STANDARD_TIM_2, TRUE, 2U);
    ECT_TIOS_IOS2 = 0U; // input capture
    ECT_TCTL4_EDG2A = 1U; // capture on both edge
    ECT_TCTL4_EDG2B = 1U;
    ECT_TIE_C2I = 1U; // enable interrupt;
#endif

#ifdef PWM_CAPTURE_SIGIN2_CHANNEL
    (void)XGate_AddrGlobalToXGate(&dat, &PwmCapture_DataList[PWM_CAPTURE_SIGIN2_CHANNEL]);
    XGateIrq_InstallVector(IRQ_STANDARD_TIM_3, func, dat);
    HC12XIrq_InstallVector(IRQ_STANDARD_TIM_3, onSIGIN2Edge, 0U);
    XGate_RouteInterrupt(IRQ_STANDARD_TIM_3, TRUE, 2U);
    ECT_TIOS_IOS3 = 0U; // input capture
    ECT_TCTL4_EDG3A = 1U; // capture on both edge
    ECT_TCTL4_EDG3B = 1U;
    ECT_TIE_C3I = 1U; // enable interrupt;
#endif
}


#ifdef PWM_CAPTURE_CP_CHANNEL
uint16 CP_GetFrequence(void) {
    uint32 f = PwmCapture_GetFrequence(&PwmCapture_DataList[PWM_CAPTURE_CP_CHANNEL]);
    if (f > 65535UL) {
        f = 65535UL;
    }
    return (uint16)f;
}

uint16 CP_GetDuty(void) {
    return PwmCapture_GetDuty(&PwmCapture_DataList[PWM_CAPTURE_CP_CHANNEL]);
}

#endif


#include <stdio.h>
#include "shell.h"

const char shell_summary_cppwm[] = "dump CP frequence and duty";
const char shell_help_cppwm[] = "\
\n\
    dump CP frequence and duty.\n\
";

int shell_func_cppwm(int argc, const char *const *argv);

int shell_func_cppwm(int argc, const char *const *argv) {
    int ret;
    if (argc == 1) {
        (void)printf("%d,%d\n", (int)CP_GetFrequence(), (int)CP_GetDuty());
        ret = 0;
    } else {
        ret = Shell_ArgsError(argv[0]);
    }
    return ret;
}
